# CMPUT 659 Assignment 1 Report
[-> github](https://github.com/uduse/cmput-659-xai)

## The Domain Specific Language (DSL)
The provided DSL is very limited in flexibility and parsing string representation of a DSL is convoluted. As a result, I wrote my own version of the DSL.

### DSL Grammar
```python
grammar = {
    Rule.START: (
        Rule.BLOCK,
    ),
    Rule.BLOCK: (
        Diminishing(0.5, Rule.IF_BLOCK),
    ),
    Rule.IF_BLOCK: (
        [Rule.BOOL_EXP, Rule.IF_BODY],
    ),
    Rule.IF_BODY: [
        Weighted({
            7: Rule.RETURN,
            3: [Rule.BLOCK, Rule.RETURN],
        })
    ],
    Rule.BOOL_EXP: [
        Rule.BOOL, 
        Rule.AND_EXP,
        Rule.NOT_EXP,
    ],
    Rule.AND_EXP: (
        [Rule.BOOL, Rule.BOOL],
    ),
    Rule.NOT_EXP: (
        Rule.BOOL,
    ),
    Rule.BOOL: (
        Rule.FUNC_CALL,
    ),
    Rule.FUNC_CALL: tuple(
        make_dynamic_rule(name) for name in lib_func_names
    ),
    Rule.RETURN: (
        "return a",
    ),
    Rule.COLUMN_NUM: (
        '2', '3', '4', '5', '6'
    ),
    Rule.SMALL_NUM: (
        '0', '1', '2'
    )
}
```

### DSL Representation
The grammar defines the space of Abstract Syntax Tree (AST). 

Here's an example of an AST in the space.

```
Rule.START
└── Rule.BLOCK
    └── Rule.IF_BLOCK
        ├── Rule.BOOL_EXP
        │   └── Rule.NOT_EXP
        │       └── Rule.BOOL
        │           └── Rule.FUNC_CALL
        │               ├── Lib.number_positions_conquered
        │               ├── state
        │               └── Rule.COLUMN_NUM
        │                   └── 2
        └── Rule.IF_BODY
            └── Rule.RETURN
                └── return a
```

### Script Generation
A script is generated by rendering its corresponding AST. The process of sampling an AST from the grammar is stochastic, while rendering an AST to a script is deterministic.

Here's the script obtained by rendering the above AST:

```python
class Script_7534b62840e04041a875ae6799b31c31(Script):
    def get_action(self, state):
        actions = state.available_moves()
        for a in actions:
            if (not (Lib.number_positions_conquered(self, "5f73ea86", state, 2))):
                return a
            pass
        return actions[0]
```

## Redundancy Removal
My grammar supports `not` and `and` operation and that makes function calls that always returns `False` still meaningful. This means any function that has been called at least once during the evaluation is meaningful to the script. To move redundancy in the scripts, first we need to record what functions are actually called. 

I achieved this by these following steps:

#### 1. bind functions to AST nodes
By binding functions to their corresponding AST nodes, we are able to map script content back to specific nodes in the AST. This is done by assigning ID to AST nodes, and have all functions rendered in a way that incorporates the ID. For example, in the above script, we have a function like:

```python
Lib.number_positions_conquered(self, "5f73ea86", state, 2)
```

The second argument `"5f73ea86"` is the ID of the corresponding node in the AST.
Once this function is called, it will have a side effect of adding itself to the `set` of all IDs of called functions, stored in `self.call_log`.
In other words, once the above function is called, `self.call_log` will contain `"5f73ea86"` which means the node `"5f73ea86"` is marked as "called".

Now, we can remove unused function calls by pruning the AST based on the `call_log`.
However, this requires some fixing to the AST as simply taking away functions that are not called could break the validity of the AST.

For example, in `func1() and func2()`, if `func1()` always returns `True`, `func2` will never be called.
If we want to remove `func2()`, we would need to change the AST so `func1()` is no longer a part of a `Rule.AND` . There are many other ways that removing a function call would break the AST.

As a result, we want to remove in-effective blocks instead, since blocks can be removed without breaking the AST.

#### 2. bubble up marks
How do we decide what block is effective? We say that a block is effective when at least one of its children is effective.
Therefore, we want to update the `call_log` so it includes all nodes that have at least one marked child.
We achieve this by bubbling the marks for all nodes in the `call_log`.

For example, if we have an AST with marked nodes denoted as `X`:

```
O
└── O
    ├── X
    └── O
```

We bubble up the marks and now it will look like this:

```
X
└── X
    ├── X
    └── O
```

#### 3. remove nodes in the AST
Now we know that all nodes that are not marked have no impact during the evaluation.
We remove all these nodes.
If we removed any of the nodes, the script has to be re-rendered based on the new AST.

## Genetic Algorithm

### Mutation
Mutation is done by re-sampling a tree from an `Rule.IF_BLOCK` node.

